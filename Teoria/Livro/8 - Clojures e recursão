Clojures são basicamente funções que retornam outras funções como "objetos".

Um exemplo bem comum de clojure em Go:

    func makeEvenGenerator() func() uint {
        i := uint(0)
        return func() (ret uint) {
            ret = i
            i += 2
            return
        }
    }

    func main() {
        nextEven := makeEvenGenerator()
        fmt.Println(nextEven())
        fmt.Println(nextEven())
        fmt.Println(nextEven())
    }

A função makeEvenGenerator retorna uma função que retorna um tipo uint (unsigned int) e a função que a função
retorna é uma função anônima que retorna um uint.

A função retornada retorna ret (observe que no return nada é passado, isso porque já foi dito que ret iria ser
retornada no começo da função). Antes de usarmos a função precisamos meio que "instanciar ela" dentro de uma
variável, como se tivéssemos utilizando objetos mesmo.

Uma "instância" dessa função não muda a outra, veja

    func makeEvenGenerator() func() uint {
        i := uint(0)
        return func() (ret uint) {
            ret = i
            i += 2
            return
        }
    }

    func main() {
        even1:= makeEvenGenerator()
        even2:= makeEvenGenerator()

        fmt.Println(even1(), even2(), even1(), even2())
    }

Saída:
0 0 2 2

RECURSÃO

Finalmente, funções são hábeis de chamar elas mesmas, veja uma função recursiva para calcular o fatorial
de um número:

    func factorial(x uint) uint {
        if x == 0 { return 1 }
        return x * factorial(x - 1)
    }

Se x == 0 ela retorna 1 (fatorial de zero é um) e caso ela não seja, ela retorna x vezes o fatorial de
x menos 1 (literalmente a mesma operação que o fatorial faz).

Clojures e recursividade são recursos poderosos que são muito utilizados no paradigma da programação funcional, mas
eu ainda não aprendi direito como utilizar esse paradigma, então depois eu falo sobre ele.
