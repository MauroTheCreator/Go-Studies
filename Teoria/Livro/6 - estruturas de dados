As estruturas de dados do Go são diferenciadas também, as mais básicas são:

    - arrays
    - slices
    - maps

ARRAY

Array é uma sequência de elementos indexados e de mesmo tipo com um tamanho fixo. No Go eles tem a forma:

    var x [tamanho]tipo

Nesse programa de exemplo podemos entender melhor:

    func main() {
        var array [5]int
        array[0] = 1 // setamos array[0] para 1
        fmt.Println(array)
    }

Nós devemos ver isso:

    [1 0 0 0 0]

Além da sintaxe longa, Go também fornece uma sintaxe mais curta para a criação de arrays, veja:

    x := [3]float64 {1, 2, 3}

Às vezes a array é longa demais pra ser declarada em uma linha, então podemos fazer:

    x := [9]int {
        1, 2, 3,
        4, 5, 6,
        7, 8, 9
    }
Pois a linguagem Go ignora quase completamente os espaços. 

Aqui outro exemplo de programa que usa arrays:

    func main() {
        var x [5]float64
        x[0] = 98
        x[1] = 93
        x[2] = 77
        x[3] = 82
        x[4] = 83
        var total float64 = 0
        for i := 0; i < len(x); i++ {
            total += x[i]
        }
        fmt.Println(total / 5)
    }

Observe que len() pode ser usada tanto com strings como com arrays, pois strings são a mesma coisa que
uma array de caracteres.

Também temos um range, mas o range é um comando, e não uma função. E diferente do Python, ele sempre retorna
o valor e o index do valor na array, assim:

    for i, value := range x {
        // comandos
    }

Mas esse código dá um erro, pois o Go não nos deixa criar variáveis que não utilizamos dentro do programa,
para evitar esse comportamento podemos utilizar uma variável com apenas um underline (_), assim, o compi
lador Go vai entender que não precisamos daquela variável.

As arrays são imutáveis, no sentido de que elas não podem crescer ou diminuir de tamanho. Mas temos outro
tipo de dado para esse caso.

SLICE

O slice é um segmento de array, eles tem index e tem um tamanho, porém, diferente das arrays eles são auto
rizados a mudar de tamanho. Aqui está um exemplo de slice:

    var c []int

A única diferença entre isso e a array é que aqui não temos o tamanho entre colchetes, nesse caso, c é
um slice criado com o tamanho de 0. Caso você queira criar um slice com um tamanho maior que isso você
terá que usar a função make().

    x := make([]int, 5)

Agora criamos um slice de tamanho inicial 5. Isso vai criar um slice relacionado com uma array de tipo
subjacente inteiro e tamanho 5. Slices sempre são relacionados à arrays e, embora eles nunca consigam
ser maiores que as arrays relacionadas, eles conseguem ser menores. A função make() também suporta um
3º parâmetro:

    x := make([]int, 5, 10)

O slice, nesse caso, vai apontar para uma array subjacente de tipo inteiro, esse slice tem tamanho 5
e capacidade pra 10. Outra forma de criar slices é usando a forma [low : high]

    var arr [5]float64 {1, 2, 3, 4, 5}
    x := arr[0:5]

low é o index onde o slice começa e high é onde o slice termina (mas não incluindo o index em si)
Por conveniencia nós podemos omitir low e high ou até mesmo os dois. Veja:

    arr[0:]
    arr[:5]
    arr[:]

APPEND 

A função append() adiciona novos elementos dentro de um slice caso ele ainda tenha capacidade pra isso, caso
não, uma nova array é criada, todos os elementos de uma array são copiados para a nova array, o elemento
é adicionado no final dessa array e um novo slice é criado e retornado:

    func main() {
        slice1 := []int {1, 2, 3}
        slice2 := append(slice1, 4, 5)
        fmt.Println(slice1, slice2)
    }

Depois de rodar esse programa, slice1 tem [1, 2, 3] e slice2 tem [1, 2, 3, 4, 5]. 

COPY

A função copy() tem dois argumentos, dst e src (destiny, source). Ela basicamente copia um slice para outro
slice sobrescrevendo qualquer coisa que tinha nele antes. 

MAPAS

Além das arrays e slices, o Go tem outra estrutura de dados chamada "map". Um map é uma coleção não-ordenada de valores mapeados por chaves,
(maps às vezes são chamados de array associativa, hash table ou dicionários). Maps são usados para achar valores de acordo com sua chave
associativa, um exemplo de map em Go é:

    var x map[string]int

O tipo map é representado dentro da linguagem pela palavra chave map, seguido pelo tipo das chaves em colchetes e o tipo dos valores
logo depois (sim, até maps tem que ter tipos nas keys e values). Tente rodar o seguinte código:

    var x map[string]int
    x["key"] = 10
    fmt.Println(x)

Você deverá receber um erro parecido com este:
    panic: runtime error: assignment to entry in nil map

    goroutine 1 [running]:
    main.main()
    main.go:7 +0x4d
    
    goroutine 2 [syscall]:
    created by runtime.main

Até agora só vimos erros de tempo de compilação, e não runtime errors. Runtime errors acontecem em tempo de execução do programa, compiletime
errors acontecem na hora da compilação do programa. O erro aqui aconteceu porque maps precisam ser inicializados antes de usados, então
precisamos substituir a primeira linha do código por:

    x := make(map[string]int)

Isso parece demais com uma array, mas temos algumas diferenças que precisamos notar:

1. O len() de um map pode mudar conforme adicionamos novos itens nele
2. Maps não são sequenciais, se temos um x[1] isso implica que precisamos ter um x[0], nos maps isso não é
   verdade.

Ok, agora vamos aprender a utilizar maps nos nossos programas. Primeiro precisamos aprender acessar valores dentro de um map, veja:

    func main() {
        elements := make(map[string]string)
        elements["H"] = "Hydrogen"
        elements["He"] = "Helium"
        elements["Li"] = "Lithium"
        elements["Be"] = "Beryllium"
        elements["B"] = "Boron"
        elements["C"] = "Carbon"
        elements["N"] = "Nitrogen"
        elements["O"] = "Oxygen"
        elements["F"] = "Fluorine"
        elements["Ne"] = "Neon"

        
        fmt.Println(elements["Li"])
    }

Aqui criamos um map com as keys e values de tipo string, nele temos alguns elementos da tabela periódica, essa é a utilização mais
comum dos maps: sendo dicionários ou tabelas.

Vamos tentar acessar um valor dentro de elements que não existe:

    fmt.Println(elements["Un"])

Esse comando não vai retornar erro, você apenas não verá nada. Tecnicamente, um mapa retorna o valor zero para o tipo de valor (que para 
strings é a string vazia). Embora pudéssemos verificar o valor zero em uma condição (elementos ["Un"] == ""), Go fornece uma maneira melhor:

    name, ok := elements["Un"]

Acessar os valores de um map pode retornar dois valores ao invés de apenas um. O primeiro valor é o resultado da busca, o segundo valor diz
se a busca foi ou não bem-sucedida. Nós frequentemente vemos esse tipo de código:

    if name, ok := elements["Un"]; ok {
        fmt.Println(name, ok)
    }

Primeiro tentamos pegar um valor dentro do map, então, se a operação foi bem sucedida rodamos o código dentro do bloco de comandos.

Lembra das arrays? Pois é, nos maps também temos formas mais curtas de declará-losm, veja:

    elements := map[string]string{
        "H": "Hydrogen",
        "He": "Helium",
        "Li": "Lithium",
        "Be": "Beryllium",
        "B": "Boron",
        "C": "Carbon",
        "N": "Nitrogen",
        "O": "Oxygen",
        "F": "Fluorine",
        "Ne": "Neon",
    }

Maps podem ser usados para guardar informação no geral, isso inclui arrays, slices e outros maps, vamos recriar o código
dos elementos e, dessa vez, mostraremos também o estado dos elementos.

    func main() {
        elements := map[string]map[string]string{
            "H": map[string]string{
                "name":"Hydrogen",
                "state":"gas",
            },

            "He": map[string]string{
                "name":"Helium",
                "state":"gas",
            },
            
            "Li": map[string]string{
                "name":"Lithium",
                "state":"solid",
            },
            
            "Be": map[string]string{
                "name":"Beryllium",
                "state":"solid",
            },

            "B": map[string]string{
                "name":"Boron",
                "state":"solid",
            },
            
            "C": map[string]string{
                "name":"Carbon",
                "state":"solid",
            },
            
            "N": map[string]string{
                "name":"Nitrogen",
                "state":"gas",
            },
            
            "O": map[string]string{
                "name":"Oxygen",
                "state":"gas",
            },
            
            "F": map[string]string{
                "name":"Fluorine",
                "state":"gas",
            },
            
            "Ne": map[string]string{
                "name":"Neon",
                "state":"gas",
            },
        }

        if element, ok := elements["Li"]; ok {
            fmt.Println(element["name"], element["state"])
        }
    }

Note que o tipo do nosso map mudou de map[string]string para map[string]map[string]string, pois, nós agora temos um map que tem o tipo
das keys sendo strings e o tipo dos valores sendo outros maps, e precisamos declarar os tipos das keys e dos valores dentro desse outro
map para podermos usar o map pai.

