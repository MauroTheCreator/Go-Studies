Vamos entender agora como definir variáveis e constantes em Go.

Existem diversas formas de definir variáveis em Go, uma delas é usando a palavra chave var. Observe que Go coloca o tipo da variável 
depois do nome dela, assim:

    var teste string

Você pode definir várias variáveis em uma mesma linha, assim:

    var teste, outroTeste, maisUmTeste string

Você pode definir uma variável com valor inicial também:

    var teste string = "isso é uma variável de teste"

Você também pode definir várias variáveis com valores iniciais, assim:

    var var1, var2, var3 type = v1, v2, v3

Você achou tedioso definir variáveis dessa maneira? Não se preocupe, a equipe de desenvolvimento da Go também achou que isso
poderia ser um problema, então você pode omitir o tipo da variável, assim:

    var var1, var2, var3 = v1, v2, v3

Bem, talvez isso ainda não seja o suficiente pra você, vamos ver como podemos melhorar:

    var1, var2, var3 := v1, v2, v3

Bem melhor, use := para declarar variáveis omitindo var e type, isso é chamado de "brief statement". Mas o problema disso é que
isso só pode ser usado dentro de funções, você receberá erros de compilação se tentar fazer variáveis globais dessa forma, portanto
usamos var para declarações de variáveis globais e usamos var() para a definição de variáveis globais de forma curta.

_ (blanck) é um nome especial pra variáveis, qualquer valor que seja atribuído à esse nome será completamente ignorado (go não deixa
que você declare variáveis e não as use, então o blanck é bem útil para valores de retorno de funções).

CONSTANTES

Constantes são valores que são declarados no programa em tempo de compilação e você não pode alterá-los em tempo de execução. Em Go
você pode usar números, booleans ou strings como valores de constantes:

    const CONSTANTE = value

Você pode atribuir o tipo da constante se for necessário

    const CONSTANTE float32 = value

TIPOS ELEMENTARES

1. Bool

Bool em Go é apenas true ou false. O seu valor padrão é false (ou seja, quando você declarar uma varíavel boolean e não atribuir valor
a ela, o valor dela será automaticamente false até algo mudá-lo).


2. Tipos numéricos

Tipos inteiros incluem tipos com sinais e sem sinais. Go possui os tipos int e uint, os quais possuem o mesmo comprimento, porém, o 
comprimento específico depende do sistema operacional. Eles utilizam 32 bits em sistemas operacionais 32 bits e 64 bits em sistemas
operacionais de 64 bits. 

Go também têm tipos que possuem comprimentos específicos, incluindo rune, int8, int16, int32, int64, byte, uint8, uint16, uint32,
uint64. Note que rune é um pseudônimo de int32 e byte é um pseudônimo de uint8.

Uma coisa importante que você deve saber é que você não pode atribuir valores entre estes tipos, esta operação irá gerar erros de compilação.

    var a int8 = 1

    var b int32 = 1

    c := a + b

Tipos float possuem os tipos float32 e float64 e nenhum tipo chamado float. O último é o tipo padrão utilizado em declarações curtas.

Isto é tudo? Não! Go também suporta números complexos. complex128 (com uma parte de 64 bits real e uma parte de 64 bits imaginária) 
é o tipo padrão, mas se você precisa de um tipo menor, existe um tipo chamado complex64 (com uma parte de 32 bits real e uma parte 
de 32 bits imaginária).


3. Strings

Nós falamos apenas sobre como a linguagem Go utiliza o conjunto de caracteres UTF-8. As strings são representadas por aspas duplas "" 
ou crases (backticks) `` .

É impossível alterar valores de string pelo índice. Você receberá erros ao compilar o seguinte código.

    var s string = "hello"
    s[0] = 'c'

Mas e se eu quiser realmente alterar um caractere individual de uma string? Ok, faça o seguinte:

    s := "hello"
    c := []byte(s)  // converte string para o tipo []byte
    c[0] = 'c'
    s2 := string(c)  // converte novamente para o tipo string
    fmt.Printf("%s\n", s2)

Use o operador + para combinar duas strings.

    s := "hello, "
    m := " world"
    a := s + m
    fmt.Printf("%s\n", a)

E também:

    s := "hello"
    s = "c" + s[1:] // você não pode alterar valores da string pelo índice, mas você pode obter os valores
    fmt.Printf("%s\n", s)

E se eu quiser ter uma string de múltiplas linhas?

    m := `hello
    world`

` não irá escapar nenhum caractere da string.

4. Tipos error

Go possui um tipo error com o propósito de lidar com mensagens de erro. Há também um pacote errors pra lidar com os erros.

    err := errors.New("emit macho dwarf: elf header corrupted")
    if err != nil {
        fmt.Print(err)
    }

DEFINIÇÃO EM GRUPO 

Se você deseja importar vários pacotes, definir várias variáveis ou várias constantes ao mesmo tempo você pode usar 
a forma de grupo, assim:

    import "fmt"
    import "os"

    const i = 100
    const pi = 3.1415
    const prefix = "Go_"

    var i int
    var pi float32
    var prefix string

Fica assim:

    import(
        "fmt"
        "os"
    )

    const(
        i = 100
        pi = 3.1415
        prefix = "Go_"
    )

    var(
        i int
        pi float32
        prefix string
    )

Ao menos que você atribua, o valor padrão das constantes é iota, o primeiro valor constante no grupo const() será 0. Se as constantes
seguintes não atribuires valores explicitamente, seus valores serão iguais ao último. Se o valor da última constante é iota, os valores
das constantes seguintes que não foram atribuidas serão iota também.

ENUMERAÇÃO IOTA

Go possui uma palavra chave chamada iota, essa palavra serve para fazer enum, ela começa com 0 e aumenta de 1 em 1

    const(
        x = iota  // x == 0
        y = iota  // y == 1
        z = iota  // z == 2
        w  // se não há nenhuma expressão após o nome da constate, ele usa a última expressão, ou seja, 
           // está definindo w = iota implicitamente. Portanto, w == 3, e y e x podem omitir "= iota" também.
    )

    const v = iota // uma vez que iota encontra a palavra-chave `const`, ela é redefinida para `0`, então v = 0.

    const (
    e, f, g = iota, iota, iota // e=0,f=0,g=0 valores de iota são iguais em uma linha.
    )

Algumas regras:
A razão de Go ser concisa é que ela possui alguns comportamentos padrão
1. Qualquer variável que começa com letra maiúscula significa que ela vai ser exportada,
   caso contrário ela é privada.

2. A mesma regra se aplica pra funções e constantes, sendo que não existem as palavras
   chave public e private em Go.

ARRAY, SLICE, MAP

1. Array

array é um array obviamente, e nós definimos ele da seguinte maneira.

    var arr [n~]type

Em [n]type n é o comprimento da array enquanto type é o tipo dos elementos dentro dela.
Assim como em outras linguagens, nós utilizamos [] para obter ou definir valores de elementos no array.

    var arr [10]int  // um array de tipo [10]int

    arr[0] = 42      // array é baseado em 0
    arr[1] = 13      // atribuir um valor ao elemento

    fmt.Printf("The first element is %d\n", arr[0])  // obtém o valor do elemento, irá retornar 42
    fmt.Printf("The last element is %d\n", arr[9]) // retorna o valor padrão do elemento da posição 10 do array, que, neste caso, é 0.

Como o comprimento faz parte do tipo do array, [3]int e [4]int são tipos diferentes, portanto, não podemos alterar o comprimento dos
arrays. Quando você utiliza arrays como argumentos, as funções obtêm suas copias em vez de referências! Se você deseja utilizar 
referências, você pode utilizar slice. Falaremos sobre isto mais tarde.

É possível utilizar := quando você define arrays.

    a := [3]int{1, 2, 3} // define um array de inteiros com 3 elementos

    b := [10]int{1, 2, 3} // define um array de inteiros com 10 elementos, dos quais os 3 primeiros são 
                         // atribuídos. O restante deles recebe o valor padrão 0.

    c := [...]int{4, 5, 6} // usa `…` para substituir o parâmetro de comprimento e a Go irá calcular isto para você.

Você pode querer utilizar arrays como elementos de arrays'. Vamos ver como fazer isto.

    // define um array bidimensional com 2 elementos, e cada elemento possui 4 elementos
    doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}

    // A declaração pode ser escrita de forma mais concisa da seguinte forma.
    easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}

2. Slice

Em várias situações, o tipo array não é uma boa escolha -por exemplo quando não sabemos o comprimento que o array terá quando o 
definimos. Sendo assim, precisamos de um "array dinâmico". Isto é chamado de slice em Go.

slice não é realmente um array dinâmico. É um tipo de referência. slice aponta para um array subjacente cuja declaração é semelhante
ao array, porém não precisa de um comprimento preestabelecido.

    // definimos um slice assim como definimos um array, mas desta vez, omitimos o comprimento
    var fslice []int

Então nós definimos um slice e inicializamos seus dados.

    slice := []byte {'a', 'b', 'c', 'd'}


slice pode redefinir slices ou arrays existentes. slice usa array[i:j] para "cortar", onde i é o índice de início e j é o índice
final, mas observe que o valor de array[j] não será incluído no slice, pois o comprimento da fatia é j-i.

    // define um array com 10 elementos cujos tipos são bytes
    var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}

    // define dois slices com o tipo []byte
    var a, b []byte

    // 'a' aponta para os elementos da terceira até a quinta posição do array ar
    a = ar[2:5]
    // agora 'a' possui os elementos ar[2], ar[3] e ar[4]

    // 'b' é outro slice do array ar
    b = ar[3:5]
    // agora 'b' possui os elementos ar[3] e ar[4]

Observe as diferenças entre slice e array quando você define eles. Nós utilizamos […] para deixar a linguagem Go calcular o 
comprimento, mas utilizamos [] para definir um slice.

A estrutura de dados slice possui algumas operações convenientes:

- Slice é baseado em 0, ar[:n] é igual a ar[0:n]
- Se omitido, o segundo índice será o comprimento do slice, ar[n:] igual a ar[n:len(ar)].
- Você pode usar ar[:] para "cortar" o array inteiro, as razões são explicadas nas duas primeiras declarações.

Mais exemplos referentes à slice:

    // define um array
    var array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}

    // define dois slices
    var aSlice, bSlice []byte

    // algumas operações convenientes
    aSlice = array[:3] // igual a aSlice = array[0:3] aSlice possui os elementos a,b,c
    aSlice = array[5:] // igual a aSlice = array[5:10] aSlice possui os elementos f,g,h,i,j
    aSlice = array[:]  // igual a aSlice = array[0:10] aSlice possui todos os elementos

    // slice de um slice
    aSlice = array[3:7]  // aSlice possui os elementos d,e,f,g，len=4，cap=7
    bSlice = aSlice[1:3] // bSlice contém aSlice[1], aSlice[2], então têm os elementos e,f
    bSlice = aSlice[:3]  // bSlice contém aSlice[0], aSlice[1], aSlice[2], então têm os elementos d,e,f
    bSlice = aSlice[0:5] // slice pode ser expandido no intervalo de cap, agora bSlice contém d,e,f,g,h
    bSlice = aSlice[:]   // bSlice têm os mesmos elementos do slice aSlice, os quais são d,e,f,g

slice é um tipo de referência, portanto, qualquer alteração irá afetar outras variáveis que apontam para o mesmo slice ou array. 
Por exemplo, no caso dos slices aSlice e bSlice apresentado acima, se você alterar o valor de um elemento em aSlice, bSlice também 
será alterado.

slice é como uma estrutura por definição, e contém 3 partes.

- Um ponteiro que aponta para onde o slice inicia.
- O comprimento do slice.
- Capacidade, o comprimento do índice de início para o índice final do slice

Existem algumas funções incorporadas no slice:

- len() obtém o comprimento do slice.
- cap() obtém o comprimento máximo do slice.
- append() acrescenta um ou mais elementos ao slice, e retorna um slice.
- copy() copia elementos de um slice para outro e retorna o número de elementos que foram copiados.

Atenção: append irá alterar o array para onde o slice aponta e afetará também outros slices que apontam para o mesmo array. Além 
disto, se não houver comprimento suficiente para o slice ((cap-len) == 0), append retorna um novo array para o slice. Quando isto
acontece, outros slices que estão apontando para o array antigo não serão afetados.

3. Map

O map se comporta como um dicionário do Python. Use a forma map[key_type]valueType para definí-lo.

Vamos ver um pouco de código. Os valores 'set' e 'get' em map são semelhantes ao slice, no entanto, o índice no slice só pode ser do 
tipo 'int' enquanto map pode usar muitos outros tipos, como por exemplo: int, string, ou qualquer outro que você quiser. Além disto, 
eles são capazes de usar == e != para comparar valores.

    // use string como o tipo chave, int como o tipo valor e `make` para inicializar.
    var numbers map[string] int

    // outra forma de definir map
    numbers := make(map[string]int)
    numbers["one"] = 1  // atribui valor por chave
    numbers["ten"] = 10
    numbers["three"] = 3

    fmt.Println("The third number is: ", numbers["three"]) // obtém valores
    // Isto imprime: The third number is: 3

Algumas notas sobre o uso de map:

- Map é desordenado, toda vez que você imprime map você terá resultados diferentes, é impossível obter valores por indice, você
  precisa usar a chave.
- Map não tem um comprimento fixo, é um tipo de referência assim como o slice.
- len() também funciona para o map, isso retorna quantas chaves o map tem.
- É muito fácil alterar valores de um map. Basta utilizar numbers["one"] = 11 para alterar o valor da chave para 11.

Você pode usar a forma chave:valor para inicializar valores em um map, pois map possui métodos embutidos para verificar se a 
chave existe.

Use delete para deletar um elemento em um map.

    // Inicializa um map
    rating := map[string]float32 {"C":5, "Go":4.5, "Python":4.5, "C++":2 }

    // map possui dois valores de retorno. Caso a chave não exista, o segundo valor de retorno, 
    // neste caso recebido pela variável 'ok', será falso (false). Caso contrário será verdadeiro (true).

    csharpRating, ok := rating["C#"]
    if ok {
        fmt.Println("C# is in the map and its rating is ", csharpRating)
    } else {
    fmt.Println("We have no rating associated with C# in the map")
    }

    delete(rating, "C")  // deleta o elemento com a chave "c"

Como foi dito acima, map é um tipo de referência. Se dois maps apontam para o mesmo dado subjacente, qualquer alteração irá
afetar ambos.

    m := make(map[string]string)
    m["Hello"] = "Bonjour"
    m1 := m
    m1["Hello"] = "Salut"  // agora o valor de m["hello"] é Salut
